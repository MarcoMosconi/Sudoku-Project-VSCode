# -*- coding: utf-8 -*-
"""functions.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_QY1lmwMHP1RXRX4GXIUvrVF3Wn0M9cs
"""
import numpy as np
import cv2
import matplotlib.pyplot as plt  # Add this import for plotting

def preProcess(img, kernel_size):
    imgGray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    imgBlur = cv2.GaussianBlur(imgGray, (kernel_size, kernel_size), 0)
    imgThreshold = cv2.adaptiveThreshold(imgBlur, 255, 1, 1, 11, 2)
    kernel = np.ones((3, 3), np.uint8)
    imgDilation = cv2.dilate(imgThreshold, kernel, iterations=1)

    # Display all images together
    images = [imgGray, imgBlur, imgThreshold, imgDilation]
    titles = ["Grayscale Image", "Blur Image", "Threshold Image", "Dilation Image"]

    plt.figure(figsize=(20, 16))
    for i, (image, title) in enumerate(zip(images, titles)):
        plt.subplot(1, 4, i + 1)
        plt.imshow(image, cmap='gray')
        plt.title(title, fontsize=30)
        plt.axis('off')
    plt.tight_layout()
    plt.show()
    return imgDilation, imgBlur, imgThreshold

def biggestContour(contours, img):
    contour_images = []  # Store intermediate contour images
    biggest = np.array([])
    max_area = 0
    for i in contours:
        area = cv2.contourArea(i)
        if area > 50:
            peri = cv2.arcLength(i, True)
            epsilon = 0.02
            approx = cv2.approxPolyDP(i, epsilon * peri, True)
            while len(approx) > 4 and epsilon < 0.2:
                epsilon += 0.01
                approx = cv2.approxPolyDP(i, epsilon * peri, True)
            imgBigContour = img.copy()

            if area > max_area and len(approx) == 4:
                if approx.size != 0:
                    approx = reorder(approx)
                    cv2.drawContours(imgBigContour, approx, -1, (0, 0, 255), 20)
                biggest = approx
                max_area = area
            else:
                cv2.drawContours(imgBigContour, approx, -1, (0, 0, 255), 20)

            contour_images.append(imgBigContour)  # Save the contour image

    return biggest, max_area, contour_images

def reorder(myPoints):
  myPoints = myPoints.reshape((4, 2))
  myPointsNew = np.zeros((4, 1, 2), np.int32)
  add = myPoints.sum(1)
  myPointsNew[0] = myPoints[np.argmin(add)]
  myPointsNew[3] = myPoints[np.argmax(add)]
  diff = np.diff(myPoints, axis=1)
  myPointsNew[1] = myPoints[np.argmin(diff)]
  myPointsNew[2] = myPoints[np.argmax(diff)]
  return myPointsNew

def defineGrid(image_path, size, kernel_size):
    img = cv2.imread(image_path)
    imgBlank = np.zeros((size, size, 3), np.uint8)

    imgDilated, imgBlur, imgThreshold = preProcess(img, kernel_size)

    imgContours = img.copy()
    contours, hierarchy = cv2.findContours(imgDilated, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    cv2.drawContours(imgContours, contours, -1, (0, 255, 0), 10)

    biggest, maxArea, contour_images = biggestContour(contours, img)
    if biggest.size != 0:
        biggest = reorder(biggest)
        cv2.drawContours(imgContours, biggest, -1, (0, 0, 255), 20)
        pts1 = np.float32(biggest)
        pts2 = np.float32([[0, 0], [size, 0], [0, size], [size, size]])
        matrix = cv2.getPerspectiveTransform(pts1, pts2)
        imgWarpColored = cv2.warpPerspective(img, matrix, (size, size))
        imgWarpColored = cv2.cvtColor(imgWarpColored, cv2.COLOR_BGR2GRAY)
    else:
        imgWarpColored = imgBlank.copy()

    img = cv2.resize(img, (size, size))

    # Plot only the final detected grid
    plt.figure(figsize=(5, 5))
    plt.imshow(imgWarpColored, cmap='gray')
    plt.title("Final Detected Grid")
    plt.axis('off')
    plt.tight_layout()
    plt.show()

    return imgWarpColored

defineGrid("sample/sample_wrong_grids/20250320_181133.jpg", 400, 17)